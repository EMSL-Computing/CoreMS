<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.molecular_id.factory.MolecularLookupTable API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.molecular_id.factory.MolecularLookupTable</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__author__ = &#34;Yuri E. Corilo&#34;
__date__ = &#34;Jul 02, 2019&#34;

from copy import deepcopy
import itertools
import multiprocessing
import json
import cProfile
import io
import pstats
import contextlib

from sqlalchemy.orm import scoped_session
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import load_only
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine, func
from tqdm import tqdm

from corems.encapsulation.factory.processingSetting import MolecularLookupDictSettings
from corems.encapsulation.constant import Atoms
from corems.molecular_id.factory.molecularSQL import CarbonHydrogen, HeteroAtoms, MolecularFormulaLink
from corems.encapsulation.factory.parameters import MSParameters
from corems import chunks, timeit
from corems.molecular_id.factory.molecularSQL import MolForm_SQL
import os

@contextlib.contextmanager
def profiled():
    pr = cProfile.Profile()
    pr.enable()
    yield
    pr.disable()
    s = io.StringIO()
    ps = pstats.Stats(pr, stream=s).sort_stats(&#39;cumulative&#39;)
    ps.print_stats()
    # uncomment this to see who&#39;s calling what
    # ps.print_callers()
    print(s.getvalue())

def insert_database_worker(args):
        
        results, url = args
        
        if not url:
            
            url = &#39;sqlite:///db/molformulas.sqlite&#39;

        if url[0:6] == &#39;sqlite&#39;:
            engine = create_engine(url, echo = False)
        else:
            engine = create_engine(url, echo = False, isolation_level=&#34;AUTOCOMMIT&#34;)
        
        session_factory = sessionmaker(bind=engine)
        session = session_factory()
        insert_query = MolecularFormulaLink.__table__.insert().values(results)
        session.execute(insert_query)
        session.commit()
        session.close()
        engine.dispose()

class MolecularCombinations:
     
    def __init__(self, sql_db = None):

        if not sql_db:
            
            self.sql_db = MolForm_SQL()
        else:
            
            self.sql_db = sql_db

    def cProfile_worker(self, args):
        
        cProfile.runctx(&#39;self.get_mol_formulas(*args)&#39;, globals(), locals(), &#39;mf_database_cprofile.prof&#39;)

    def check_database_get_class_list(self, molecular_search_settings):
        
        all_class_to_create = []
        
        classes_dict = self.get_classes_in_order(molecular_search_settings)
        
        class_str_set = set(classes_dict.keys())
        
        existing_classes_objs = self.sql_db.session.query(HeteroAtoms).distinct().all()
        
        existing_classes_str = set([classe.name for classe in existing_classes_objs])

        self.len_existing_classes = len(existing_classes_str)

        class_to_create = class_str_set - existing_classes_str
        
        class_count= len(existing_classes_objs)

        data_classes = list()    
        for index, class_str in enumerate(class_to_create):
            
            class_dict = classes_dict.get(class_str)
            halogen_count = self.get_total_halogen_atoms(class_dict)
            data_classes.append({&#34;name&#34;:class_str, &#34;id&#34;:class_count+ index + 1, &#34;halogensCount&#34;: halogen_count})

        #data_classes = [{&#34;name&#34;:class_str, &#34;id&#34;:class_count+ index + 1} for index, class_str in enumerate(class_to_create)]

        if data_classes:

            list_insert_chunks = chunks(data_classes, self.sql_db.chunks_count)
            for insert_chunk in  list_insert_chunks:   
                insert_query = HeteroAtoms.__table__.insert().values(insert_chunk)
                self.sql_db.session.execute(insert_query)

        for index, class_str in enumerate(class_to_create):

            class_tuple = (class_str, classes_dict.get(class_str), class_count+ index + 1)

            all_class_to_create.append(class_tuple)

        return [(c_s, c_d) for c_s, c_d in classes_dict.items()], all_class_to_create, existing_classes_objs       

    def get_carbonsHydrogens(self, settings, odd_even):

        operator = &#39;==&#39; if odd_even == &#39;even&#39; else &#39;!=&#39; 
        usedAtoms = settings.usedAtoms
        user_min_c, user_max_c = usedAtoms.get(&#39;C&#39;)
        user_min_h, user_max_h = usedAtoms.get(&#39;H&#39;)

        return eval(&#34;self.sql_db.session.query(CarbonHydrogen).filter(&#34; 
                                       &#34;CarbonHydrogen.C &gt;= user_min_c,&#34;
                                        &#34;CarbonHydrogen.H &gt;= user_min_h,&#34;
                                        &#34;CarbonHydrogen.C &lt;= user_max_c,&#34;
                                        &#34;CarbonHydrogen.H &lt;= user_max_h,&#34;
                                        &#34;CarbonHydrogen.H % 2&#34; + operator+ &#34;0).all()&#34;)

    def add_carbonsHydrogens(self, settings, existing_classes_objs):

        usedAtoms = settings.usedAtoms

        user_min_c, user_max_c = usedAtoms.get(&#39;C&#39;)
        user_min_h, user_max_h = usedAtoms.get(&#39;H&#39;)

        query_obj = self.sql_db.session.query(func.max(CarbonHydrogen.C).label(&#34;max_c&#34;), 
                        func.min(CarbonHydrogen.C).label(&#34;min_c&#34;),
                        func.max(CarbonHydrogen.H).label(&#34;max_h&#34;),
                        func.min(CarbonHydrogen.H).label(&#34;min_h&#34;),
                        )


        database = query_obj.first()
        if database.max_c == user_max_c and database.min_c == user_min_c and database.max_h == user_max_h and database.min_h == user_min_h:   
            #all data is already available at the database
            pass

        else:

            current_count = self.sql_db.session.query(CarbonHydrogen.C).count()
            
            databaseCarbonHydrogen = self.sql_db.session.query(CarbonHydrogen).all()
            
            userCarbon = set(range(user_min_c, user_max_c + 1))
            userHydrogen = set(range(user_min_h, user_max_h + 1))
            
            carbon_hydrogen_objs_database = {}
            for obj in databaseCarbonHydrogen:
                
                str_data = &#34;C:{},H:{}&#34;.format(obj.C, obj.H)
                carbon_hydrogen_objs_database[str_data] = str_data

            carbon_hydrogen_objs_to_create = {&#39;even&#39;: {}, &#39;odd&#39;: {}}
            
            list_ch_obj_to_add = list()
            i = 0
            for comb in itertools.product(userCarbon, userHydrogen):
                
                C  = comb[0]
                H =  comb[1]
                data = {&#34;C&#34;:C,
                       &#34;H&#34;:H,
                }

                data_insert = {&#34;C&#34;:C,
                       &#34;H&#34;:H,
                }

                str_data = &#34;C:{},H:{}&#34;.format(C,H)
                
                if not str_data in carbon_hydrogen_objs_database.keys():
                    
                    label = &#39;even&#39; if comb[1]%2 == 0 else &#39;odd&#39;
                    data[&#34;mass&#34;] = (C * Atoms.atomic_masses.get(&#39;C&#39;)) + (H * Atoms.atomic_masses.get(&#39;H&#39;))
                    data[&#34;dbe&#34;] = C - (H/2) + 1
                    data[&#34;id&#34;] = i + current_count + 1
                    data_insert[&#34;id&#34;] = i + current_count + 1
                    i = i + 1 
                    carbon_hydrogen_objs_to_create[label][str_data] = data
                    
                    list_ch_obj_to_add.append(data_insert)

            if list_ch_obj_to_add:
                # insert carbon hydrogen objs
                list_insert_chunks = chunks(list_ch_obj_to_add, self.sql_db.chunks_count)
                for insert_chunk in  list_insert_chunks:   
                    insert_query = CarbonHydrogen.__table__.insert().values(insert_chunk)
                    self.sql_db.session.execute(insert_query)
                self.sql_db.session.commit()    
            
                
                list_molecular_form= list()
                for classe_obj in existing_classes_objs:

                    classe_dict = classe_obj.to_dict()  
                    classe_mass = self.calc_mz(classe_dict)
                    classe_dbe = self.calc_dbe_class(classe_dict)

                    odd_even_label = self.get_h_odd_or_even(classe_dict)

                    ch_datalist = carbon_hydrogen_objs_to_create.get(odd_even_label).values()

                    for ch_dict in ch_datalist:
                        mass = ch_dict.get(&#39;mass&#39;) + classe_mass
                        dbe = ch_dict.get(&#39;dbe&#39;) + classe_dbe

                        if settings.min_mz &lt;= mass &lt;= settings.max_mz:
                
                            if settings.min_dbe &lt;= dbe &lt;= settings.max_dbe:
                                
                                list_molecular_form.append( {&#34;heteroAtoms_id&#34;:classe_obj.id, 
                                        &#34;carbonHydrogen_id&#34;:ch_dict.get(&#39;id&#39;), 
                                        &#34;mass&#34;:mass, &#34;DBE&#34;:dbe})

                list_insert_chunks = chunks(list_molecular_form, self.sql_db.chunks_count)
                for insert_chunk in  list_insert_chunks:   
                    insert_query = MolecularFormulaLink.__table__.insert().values(insert_chunk)
                    self.sql_db.session.execute(insert_query)
                self.sql_db.session.commit()    
            
                
    @timeit
    def runworker(self, molecular_search_settings):
        
        classes_list, class_to_create, existing_classes_objs = self.check_database_get_class_list(molecular_search_settings)
        
        settings = MolecularLookupDictSettings()
        settings.usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
        settings.url_database = molecular_search_settings.url_database
        settings.db_jobs = molecular_search_settings.db_jobs

        self.add_carbonsHydrogens(settings, existing_classes_objs)
        
        if class_to_create:
            
            settings = MolecularLookupDictSettings()
            settings.usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
            settings.url_database = molecular_search_settings.url_database
            settings.db_jobs = molecular_search_settings.db_jobs
            
            self.sql_db.session.commit()
            odd_ch_obj = self.get_carbonsHydrogens(settings,&#39;odd&#39;)
            self.odd_ch_id = [obj.id for obj in odd_ch_obj]
            self.odd_ch_dict = [{&#39;C&#39;:obj.C, &#39;H&#39;:obj.H} for obj in odd_ch_obj]
            self.odd_ch_mass = [obj.mass for obj in odd_ch_obj]
            self.odd_ch_dbe = [obj.dbe for obj in odd_ch_obj]
            
            even_ch_obj = self.get_carbonsHydrogens(settings, &#39;even&#39;)
            self.even_ch_id = [obj.id for obj in even_ch_obj]
            self.even_ch_dict = [{&#39;C&#39;:obj.C, &#39;H&#39;:obj.H} for obj in even_ch_obj]
            self.even_ch_mass = [obj.mass for obj in even_ch_obj]
            self.even_ch_dbe = [obj.dbe for obj in even_ch_obj]

            all_results= list()
            for class_tuple in tqdm(class_to_create):
                
                results = self.populate_combinations(class_tuple, settings)
                all_results.extend(results)
                if settings.db_jobs == 1: 
                    #if len(all_results) &gt;= self.sql_db.chunks_count:
                        list_insert_chunks = list(chunks(results, self.sql_db.chunks_count))
                        for chunk in list_insert_chunks:
                            insert_query = MolecularFormulaLink.__table__.insert().values(chunk)
                            self.sql_db.session.execute(insert_query)
                        #all_results = list()
            self.sql_db.session.commit()
            # each chunk takes ~600Mb of memory, so if using 8 processes the total free memory needs to be 5GB
            if settings.db_jobs &gt; 1: 
                list_insert_chunks = list(chunks(all_results, self.sql_db.chunks_count))
                print( &#34;Started database insert using {} iterations for a total of {} rows&#34;.format(len(list_insert_chunks), len(all_results)))
                worker_args = [(chunk, settings.url_database) for chunk in list_insert_chunks]
                p = multiprocessing.Pool(settings.db_jobs)
                for class_list in tqdm(p.imap_unordered(insert_database_worker, worker_args)):
                    pass
                p.close()
                p.join()
        
        return classes_list
    
    def get_classes_in_order(self, molecular_search_settings):
        &#39;&#39;&#39; structure is 
            (&#39;HC&#39;, {&#39;HC&#39;: 1})&#39;&#39;&#39;
        
        usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
        
        usedAtoms.pop(&#34;C&#34;)
        usedAtoms.pop(&#34;H&#34;)

        min_n, max_n = usedAtoms.get(&#39;N&#39;) if usedAtoms.get(&#39;N&#39;) else (0,0)
        min_o, max_o = usedAtoms.get(&#39;O&#39;) if usedAtoms.get(&#39;O&#39;) else (0,0)
        min_s, max_s = usedAtoms.get(&#39;S&#39;) if usedAtoms.get(&#39;S&#39;) else (0,0)
        min_p, max_p = usedAtoms.get(&#39;P&#39;) if usedAtoms.get(&#39;P&#39;) else (0,0)

        possible_n = [n for n in range(min_n, max_n + 1)]
        possible_o = [o for o in range(min_o, max_o + 1)]
        possible_s = [s for s in range(min_s, max_s + 1)]
        possible_p = [p for p in range(min_p, max_p + 1)]
        
        atoms_in_order = [&#39;N&#39;, &#39;O&#39;, &#39;S&#39;, &#39;P&#39;]

        classe_in_order = {}

        all_atoms_tuples = itertools.product(possible_n, possible_o,
                                            possible_s, possible_p)
        
        for atom in atoms_in_order:
            usedAtoms.pop(atom, None)
        
        for selected_atom, min_max_tuple in usedAtoms.items():
            
            min_x = min_max_tuple[0]
            max_x = min_max_tuple[1]
            

            possible_x = [x for x in range(min_x, max_x + 1)]

            all_atoms_tuples = itertools.product(all_atoms_tuples, possible_x)
            all_atoms_tuples = [all_atoms_combined[0] + (all_atoms_combined[1],) for all_atoms_combined in
                                all_atoms_tuples]
            atoms_in_order.append(selected_atom)
        
        for all_atoms_tuple in all_atoms_tuples:

            classe_str = &#39;&#39;
            classe_dict = {}
            
            for each_atoms_index, atom_number in enumerate(all_atoms_tuple):
                
                if atom_number != 0:
                    classe_dict[atoms_in_order[each_atoms_index]] = atom_number
            
            if not classe_dict:
                classe_in_order[&#39;HC&#39;] = {&#34;HC&#34;: &#34;&#34;}
                continue

            classe_str =json.dumps(classe_dict)
            
            if len(classe_str) &gt; 0:
                
                classe_in_order[classe_str] =  classe_dict
        
        classe_in_order_dict = self.sort_classes(atoms_in_order, classe_in_order)
        
        return classe_in_order_dict

    @staticmethod
    def sort_classes( atoms_in_order, combination_dict) -&gt; [str]: 
        #ensures atoms are always in the order defined at atoms_in_order list
        join_dict_classes = dict()
        atoms_in_order =  [&#39;N&#39;,&#39;S&#39;,&#39;P&#39;,&#39;O&#39;] + atoms_in_order[4:] + [&#39;HC&#39;]
        
        sort_method = lambda atoms_keys: [atoms_in_order.index(atoms_keys)] 
        for class_str, class_dict in combination_dict.items():
            
            sorted_dict_keys = sorted(class_dict, key = sort_method)
            class_dict = { atom: class_dict[atom] for atom in sorted_dict_keys}
            class_str = json.dumps(class_dict)
            # using json for the new database, class 
            # class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in sorted_dict_keys])
            join_dict_classes[class_str] =  class_dict
        
        return join_dict_classes

    @staticmethod
    def get_fixed_initial_number_of_hydrogen( min_h, odd_even):

        remaining_h = min_h % 2
        
        if odd_even == &#39;even&#39;:
            
            if remaining_h == 0: return remaining_h
            
            else: return remaining_h + 1    
        
        else:
            
            if remaining_h == 0: return remaining_h + 1
            
            else: return remaining_h    

    def calc_mz(self, datadict, class_mass=0):
        
        mass = class_mass
        
        for atom in datadict.keys():
            
            if atom != &#39;HC&#39;:    
                
                mass = mass + Atoms.atomic_masses[atom]  *  datadict.get(atom)
            
        return mass 
        
    def calc_dbe_class(self, datadict):
            
            init_dbe = 0
            for atom in datadict.keys():

                if atom == &#39;HC&#39;:
                    continue  
                
                n_atom = int(datadict.get(atom))
                
                clean_atom = &#39;&#39;.join([i for i in atom if not i.isdigit()]) 
                
                valencia = MSParameters.molecular_search.used_atom_valences.get(clean_atom)
                
                if type(valencia) is tuple:
                    valencia = valencia[0]
                if valencia &gt; 0:
                    #print atom, valencia, n_atom, init_dbe
                    init_dbe = init_dbe + (n_atom * (valencia - 2))
                else:
                    continue
                
            return (0.5 * init_dbe)
            
    def populate_combinations(self, classe_tuple, settings):
        
        ion_charge =  0
        
        class_dict = classe_tuple[1]
        odd_or_even = self.get_h_odd_or_even(class_dict)
        
        return self.get_mol_formulas(odd_or_even, classe_tuple, settings)
        
    def get_or_add(self, SomeClass, kw):
            
        obj = self.sql_db.session.query(SomeClass).filter_by(**kw).first()
        if not obj:
            obj = SomeClass(**kw)
        return obj
    
    
    def get_mol_formulas(self, odd_even_tag, classe_tuple, settings):
        
        class_str = classe_tuple[0]
        class_dict = classe_tuple[1]
        classe_id = classe_tuple[2]
        
        results = list()
        
        if &#39;HC&#39; in class_dict:
            del class_dict[&#39;HC&#39;]
            
        class_dbe = self.calc_dbe_class(class_dict)    
        class_mass = self.calc_mz(class_dict)
        
        carbonHydrogen_mass = self.odd_ch_mass if odd_even_tag == &#39;odd&#39; else self.even_ch_mass 
        carbonHydrogen_dbe = self.odd_ch_dbe if odd_even_tag == &#39;odd&#39; else self.even_ch_dbe 
        carbonHydrogen_id = self.odd_ch_id if odd_even_tag == &#39;odd&#39; else self.even_ch_id 
        
        for index, carbonHydrogen_obj in enumerate(carbonHydrogen_id):
            
            mass = carbonHydrogen_mass[index] + class_mass
            dbe =  carbonHydrogen_dbe[index] + class_dbe
    
            if settings.min_mz &lt;= mass &lt;= settings.max_mz:
                
                if settings.min_dbe &lt;= dbe &lt;= settings.max_dbe:
                    
                    molecularFormula=  {&#34;heteroAtoms_id&#34;:classe_id, 
                            &#34;carbonHydrogen_id&#34;:carbonHydrogen_id[index], 
                            &#34;mass&#34;:mass, &#34;DBE&#34;:dbe}
                    
                    results.append(molecularFormula)
        
        return results
        
        
    def get_h_odd_or_even(self, class_dict):

        
        HAS_NITROGEN = &#39;N&#39; in class_dict.keys()
        HAS_PHOSPHORUS = &#39;P&#39; in class_dict.keys()

        number_of_halogen = self.get_total_halogen_atoms(class_dict)

        if number_of_halogen &gt; 0:

            TEM_HALOGEN = True

        else:

            TEM_HALOGEN = False

        if TEM_HALOGEN:

            remaining_halogen = number_of_halogen % 2

        else:

            remaining_halogen = 0

        if HAS_NITROGEN and HAS_PHOSPHORUS:

            number_of_n = class_dict.get(&#39;N&#39;) + class_dict.get(&#39;P&#39;)
            remaining_n = number_of_n % 2

        elif HAS_NITROGEN and not HAS_PHOSPHORUS:

            number_of_n = class_dict.get(&#39;N&#39;)
            remaining_n = number_of_n % 2

        elif HAS_PHOSPHORUS and not HAS_NITROGEN:

            number_of_n = class_dict.get(&#39;P&#39;)
            remaining_n = number_of_n % 2

        else:

            remaining_n = -1

        if remaining_n &gt; 0.0:
            if HAS_NITROGEN or HAS_PHOSPHORUS:

                if TEM_HALOGEN:
                    if remaining_halogen == 0:
                        return &#39;odd&#39;
                    else:
                        return &#39;even&#39;
                else:
                    return &#39;odd&#39;

        elif remaining_n == 0.0:

            if HAS_NITROGEN or HAS_PHOSPHORUS:

                if TEM_HALOGEN:
                    if remaining_halogen == 0:
                        return &#39;even&#39;
                    else:
                        return &#39;odd&#39;
                else:
                    return &#39;even&#39;

        else:

            if TEM_HALOGEN:
                if remaining_halogen == 0:
                    return &#39;even&#39;
                else:
                    return &#39;odd&#39;
            else:
                return &#39;even&#39;

    @staticmethod
    def get_total_halogen_atoms(class_dict):

            atoms = [&#39;F&#39;, &#39;Cl&#39;, &#39;Br&#39;, &#39;I&#39;]

            total_number = 0
            
            for atom in atoms:

                if atom in class_dict.keys():

                    total_number = total_number + class_dict.get(atom)
            
            return total_number    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="corems.molecular_id.factory.MolecularLookupTable.insert_database_worker"><code class="name flex">
<span>def <span class="ident">insert_database_worker</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_database_worker(args):
        
        results, url = args
        
        if not url:
            
            url = &#39;sqlite:///db/molformulas.sqlite&#39;

        if url[0:6] == &#39;sqlite&#39;:
            engine = create_engine(url, echo = False)
        else:
            engine = create_engine(url, echo = False, isolation_level=&#34;AUTOCOMMIT&#34;)
        
        session_factory = sessionmaker(bind=engine)
        session = session_factory()
        insert_query = MolecularFormulaLink.__table__.insert().values(results)
        session.execute(insert_query)
        session.commit()
        session.close()
        engine.dispose()</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.profiled"><code class="name flex">
<span>def <span class="ident">profiled</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def profiled():
    pr = cProfile.Profile()
    pr.enable()
    yield
    pr.disable()
    s = io.StringIO()
    ps = pstats.Stats(pr, stream=s).sort_stats(&#39;cumulative&#39;)
    ps.print_stats()
    # uncomment this to see who&#39;s calling what
    # ps.print_callers()
    print(s.getvalue())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations"><code class="flex name class">
<span>class <span class="ident">MolecularCombinations</span></span>
<span>(</span><span>sql_db=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MolecularCombinations:
     
    def __init__(self, sql_db = None):

        if not sql_db:
            
            self.sql_db = MolForm_SQL()
        else:
            
            self.sql_db = sql_db

    def cProfile_worker(self, args):
        
        cProfile.runctx(&#39;self.get_mol_formulas(*args)&#39;, globals(), locals(), &#39;mf_database_cprofile.prof&#39;)

    def check_database_get_class_list(self, molecular_search_settings):
        
        all_class_to_create = []
        
        classes_dict = self.get_classes_in_order(molecular_search_settings)
        
        class_str_set = set(classes_dict.keys())
        
        existing_classes_objs = self.sql_db.session.query(HeteroAtoms).distinct().all()
        
        existing_classes_str = set([classe.name for classe in existing_classes_objs])

        self.len_existing_classes = len(existing_classes_str)

        class_to_create = class_str_set - existing_classes_str
        
        class_count= len(existing_classes_objs)

        data_classes = list()    
        for index, class_str in enumerate(class_to_create):
            
            class_dict = classes_dict.get(class_str)
            halogen_count = self.get_total_halogen_atoms(class_dict)
            data_classes.append({&#34;name&#34;:class_str, &#34;id&#34;:class_count+ index + 1, &#34;halogensCount&#34;: halogen_count})

        #data_classes = [{&#34;name&#34;:class_str, &#34;id&#34;:class_count+ index + 1} for index, class_str in enumerate(class_to_create)]

        if data_classes:

            list_insert_chunks = chunks(data_classes, self.sql_db.chunks_count)
            for insert_chunk in  list_insert_chunks:   
                insert_query = HeteroAtoms.__table__.insert().values(insert_chunk)
                self.sql_db.session.execute(insert_query)

        for index, class_str in enumerate(class_to_create):

            class_tuple = (class_str, classes_dict.get(class_str), class_count+ index + 1)

            all_class_to_create.append(class_tuple)

        return [(c_s, c_d) for c_s, c_d in classes_dict.items()], all_class_to_create, existing_classes_objs       

    def get_carbonsHydrogens(self, settings, odd_even):

        operator = &#39;==&#39; if odd_even == &#39;even&#39; else &#39;!=&#39; 
        usedAtoms = settings.usedAtoms
        user_min_c, user_max_c = usedAtoms.get(&#39;C&#39;)
        user_min_h, user_max_h = usedAtoms.get(&#39;H&#39;)

        return eval(&#34;self.sql_db.session.query(CarbonHydrogen).filter(&#34; 
                                       &#34;CarbonHydrogen.C &gt;= user_min_c,&#34;
                                        &#34;CarbonHydrogen.H &gt;= user_min_h,&#34;
                                        &#34;CarbonHydrogen.C &lt;= user_max_c,&#34;
                                        &#34;CarbonHydrogen.H &lt;= user_max_h,&#34;
                                        &#34;CarbonHydrogen.H % 2&#34; + operator+ &#34;0).all()&#34;)

    def add_carbonsHydrogens(self, settings, existing_classes_objs):

        usedAtoms = settings.usedAtoms

        user_min_c, user_max_c = usedAtoms.get(&#39;C&#39;)
        user_min_h, user_max_h = usedAtoms.get(&#39;H&#39;)

        query_obj = self.sql_db.session.query(func.max(CarbonHydrogen.C).label(&#34;max_c&#34;), 
                        func.min(CarbonHydrogen.C).label(&#34;min_c&#34;),
                        func.max(CarbonHydrogen.H).label(&#34;max_h&#34;),
                        func.min(CarbonHydrogen.H).label(&#34;min_h&#34;),
                        )


        database = query_obj.first()
        if database.max_c == user_max_c and database.min_c == user_min_c and database.max_h == user_max_h and database.min_h == user_min_h:   
            #all data is already available at the database
            pass

        else:

            current_count = self.sql_db.session.query(CarbonHydrogen.C).count()
            
            databaseCarbonHydrogen = self.sql_db.session.query(CarbonHydrogen).all()
            
            userCarbon = set(range(user_min_c, user_max_c + 1))
            userHydrogen = set(range(user_min_h, user_max_h + 1))
            
            carbon_hydrogen_objs_database = {}
            for obj in databaseCarbonHydrogen:
                
                str_data = &#34;C:{},H:{}&#34;.format(obj.C, obj.H)
                carbon_hydrogen_objs_database[str_data] = str_data

            carbon_hydrogen_objs_to_create = {&#39;even&#39;: {}, &#39;odd&#39;: {}}
            
            list_ch_obj_to_add = list()
            i = 0
            for comb in itertools.product(userCarbon, userHydrogen):
                
                C  = comb[0]
                H =  comb[1]
                data = {&#34;C&#34;:C,
                       &#34;H&#34;:H,
                }

                data_insert = {&#34;C&#34;:C,
                       &#34;H&#34;:H,
                }

                str_data = &#34;C:{},H:{}&#34;.format(C,H)
                
                if not str_data in carbon_hydrogen_objs_database.keys():
                    
                    label = &#39;even&#39; if comb[1]%2 == 0 else &#39;odd&#39;
                    data[&#34;mass&#34;] = (C * Atoms.atomic_masses.get(&#39;C&#39;)) + (H * Atoms.atomic_masses.get(&#39;H&#39;))
                    data[&#34;dbe&#34;] = C - (H/2) + 1
                    data[&#34;id&#34;] = i + current_count + 1
                    data_insert[&#34;id&#34;] = i + current_count + 1
                    i = i + 1 
                    carbon_hydrogen_objs_to_create[label][str_data] = data
                    
                    list_ch_obj_to_add.append(data_insert)

            if list_ch_obj_to_add:
                # insert carbon hydrogen objs
                list_insert_chunks = chunks(list_ch_obj_to_add, self.sql_db.chunks_count)
                for insert_chunk in  list_insert_chunks:   
                    insert_query = CarbonHydrogen.__table__.insert().values(insert_chunk)
                    self.sql_db.session.execute(insert_query)
                self.sql_db.session.commit()    
            
                
                list_molecular_form= list()
                for classe_obj in existing_classes_objs:

                    classe_dict = classe_obj.to_dict()  
                    classe_mass = self.calc_mz(classe_dict)
                    classe_dbe = self.calc_dbe_class(classe_dict)

                    odd_even_label = self.get_h_odd_or_even(classe_dict)

                    ch_datalist = carbon_hydrogen_objs_to_create.get(odd_even_label).values()

                    for ch_dict in ch_datalist:
                        mass = ch_dict.get(&#39;mass&#39;) + classe_mass
                        dbe = ch_dict.get(&#39;dbe&#39;) + classe_dbe

                        if settings.min_mz &lt;= mass &lt;= settings.max_mz:
                
                            if settings.min_dbe &lt;= dbe &lt;= settings.max_dbe:
                                
                                list_molecular_form.append( {&#34;heteroAtoms_id&#34;:classe_obj.id, 
                                        &#34;carbonHydrogen_id&#34;:ch_dict.get(&#39;id&#39;), 
                                        &#34;mass&#34;:mass, &#34;DBE&#34;:dbe})

                list_insert_chunks = chunks(list_molecular_form, self.sql_db.chunks_count)
                for insert_chunk in  list_insert_chunks:   
                    insert_query = MolecularFormulaLink.__table__.insert().values(insert_chunk)
                    self.sql_db.session.execute(insert_query)
                self.sql_db.session.commit()    
            
                
    @timeit
    def runworker(self, molecular_search_settings):
        
        classes_list, class_to_create, existing_classes_objs = self.check_database_get_class_list(molecular_search_settings)
        
        settings = MolecularLookupDictSettings()
        settings.usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
        settings.url_database = molecular_search_settings.url_database
        settings.db_jobs = molecular_search_settings.db_jobs

        self.add_carbonsHydrogens(settings, existing_classes_objs)
        
        if class_to_create:
            
            settings = MolecularLookupDictSettings()
            settings.usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
            settings.url_database = molecular_search_settings.url_database
            settings.db_jobs = molecular_search_settings.db_jobs
            
            self.sql_db.session.commit()
            odd_ch_obj = self.get_carbonsHydrogens(settings,&#39;odd&#39;)
            self.odd_ch_id = [obj.id for obj in odd_ch_obj]
            self.odd_ch_dict = [{&#39;C&#39;:obj.C, &#39;H&#39;:obj.H} for obj in odd_ch_obj]
            self.odd_ch_mass = [obj.mass for obj in odd_ch_obj]
            self.odd_ch_dbe = [obj.dbe for obj in odd_ch_obj]
            
            even_ch_obj = self.get_carbonsHydrogens(settings, &#39;even&#39;)
            self.even_ch_id = [obj.id for obj in even_ch_obj]
            self.even_ch_dict = [{&#39;C&#39;:obj.C, &#39;H&#39;:obj.H} for obj in even_ch_obj]
            self.even_ch_mass = [obj.mass for obj in even_ch_obj]
            self.even_ch_dbe = [obj.dbe for obj in even_ch_obj]

            all_results= list()
            for class_tuple in tqdm(class_to_create):
                
                results = self.populate_combinations(class_tuple, settings)
                all_results.extend(results)
                if settings.db_jobs == 1: 
                    #if len(all_results) &gt;= self.sql_db.chunks_count:
                        list_insert_chunks = list(chunks(results, self.sql_db.chunks_count))
                        for chunk in list_insert_chunks:
                            insert_query = MolecularFormulaLink.__table__.insert().values(chunk)
                            self.sql_db.session.execute(insert_query)
                        #all_results = list()
            self.sql_db.session.commit()
            # each chunk takes ~600Mb of memory, so if using 8 processes the total free memory needs to be 5GB
            if settings.db_jobs &gt; 1: 
                list_insert_chunks = list(chunks(all_results, self.sql_db.chunks_count))
                print( &#34;Started database insert using {} iterations for a total of {} rows&#34;.format(len(list_insert_chunks), len(all_results)))
                worker_args = [(chunk, settings.url_database) for chunk in list_insert_chunks]
                p = multiprocessing.Pool(settings.db_jobs)
                for class_list in tqdm(p.imap_unordered(insert_database_worker, worker_args)):
                    pass
                p.close()
                p.join()
        
        return classes_list
    
    def get_classes_in_order(self, molecular_search_settings):
        &#39;&#39;&#39; structure is 
            (&#39;HC&#39;, {&#39;HC&#39;: 1})&#39;&#39;&#39;
        
        usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
        
        usedAtoms.pop(&#34;C&#34;)
        usedAtoms.pop(&#34;H&#34;)

        min_n, max_n = usedAtoms.get(&#39;N&#39;) if usedAtoms.get(&#39;N&#39;) else (0,0)
        min_o, max_o = usedAtoms.get(&#39;O&#39;) if usedAtoms.get(&#39;O&#39;) else (0,0)
        min_s, max_s = usedAtoms.get(&#39;S&#39;) if usedAtoms.get(&#39;S&#39;) else (0,0)
        min_p, max_p = usedAtoms.get(&#39;P&#39;) if usedAtoms.get(&#39;P&#39;) else (0,0)

        possible_n = [n for n in range(min_n, max_n + 1)]
        possible_o = [o for o in range(min_o, max_o + 1)]
        possible_s = [s for s in range(min_s, max_s + 1)]
        possible_p = [p for p in range(min_p, max_p + 1)]
        
        atoms_in_order = [&#39;N&#39;, &#39;O&#39;, &#39;S&#39;, &#39;P&#39;]

        classe_in_order = {}

        all_atoms_tuples = itertools.product(possible_n, possible_o,
                                            possible_s, possible_p)
        
        for atom in atoms_in_order:
            usedAtoms.pop(atom, None)
        
        for selected_atom, min_max_tuple in usedAtoms.items():
            
            min_x = min_max_tuple[0]
            max_x = min_max_tuple[1]
            

            possible_x = [x for x in range(min_x, max_x + 1)]

            all_atoms_tuples = itertools.product(all_atoms_tuples, possible_x)
            all_atoms_tuples = [all_atoms_combined[0] + (all_atoms_combined[1],) for all_atoms_combined in
                                all_atoms_tuples]
            atoms_in_order.append(selected_atom)
        
        for all_atoms_tuple in all_atoms_tuples:

            classe_str = &#39;&#39;
            classe_dict = {}
            
            for each_atoms_index, atom_number in enumerate(all_atoms_tuple):
                
                if atom_number != 0:
                    classe_dict[atoms_in_order[each_atoms_index]] = atom_number
            
            if not classe_dict:
                classe_in_order[&#39;HC&#39;] = {&#34;HC&#34;: &#34;&#34;}
                continue

            classe_str =json.dumps(classe_dict)
            
            if len(classe_str) &gt; 0:
                
                classe_in_order[classe_str] =  classe_dict
        
        classe_in_order_dict = self.sort_classes(atoms_in_order, classe_in_order)
        
        return classe_in_order_dict

    @staticmethod
    def sort_classes( atoms_in_order, combination_dict) -&gt; [str]: 
        #ensures atoms are always in the order defined at atoms_in_order list
        join_dict_classes = dict()
        atoms_in_order =  [&#39;N&#39;,&#39;S&#39;,&#39;P&#39;,&#39;O&#39;] + atoms_in_order[4:] + [&#39;HC&#39;]
        
        sort_method = lambda atoms_keys: [atoms_in_order.index(atoms_keys)] 
        for class_str, class_dict in combination_dict.items():
            
            sorted_dict_keys = sorted(class_dict, key = sort_method)
            class_dict = { atom: class_dict[atom] for atom in sorted_dict_keys}
            class_str = json.dumps(class_dict)
            # using json for the new database, class 
            # class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in sorted_dict_keys])
            join_dict_classes[class_str] =  class_dict
        
        return join_dict_classes

    @staticmethod
    def get_fixed_initial_number_of_hydrogen( min_h, odd_even):

        remaining_h = min_h % 2
        
        if odd_even == &#39;even&#39;:
            
            if remaining_h == 0: return remaining_h
            
            else: return remaining_h + 1    
        
        else:
            
            if remaining_h == 0: return remaining_h + 1
            
            else: return remaining_h    

    def calc_mz(self, datadict, class_mass=0):
        
        mass = class_mass
        
        for atom in datadict.keys():
            
            if atom != &#39;HC&#39;:    
                
                mass = mass + Atoms.atomic_masses[atom]  *  datadict.get(atom)
            
        return mass 
        
    def calc_dbe_class(self, datadict):
            
            init_dbe = 0
            for atom in datadict.keys():

                if atom == &#39;HC&#39;:
                    continue  
                
                n_atom = int(datadict.get(atom))
                
                clean_atom = &#39;&#39;.join([i for i in atom if not i.isdigit()]) 
                
                valencia = MSParameters.molecular_search.used_atom_valences.get(clean_atom)
                
                if type(valencia) is tuple:
                    valencia = valencia[0]
                if valencia &gt; 0:
                    #print atom, valencia, n_atom, init_dbe
                    init_dbe = init_dbe + (n_atom * (valencia - 2))
                else:
                    continue
                
            return (0.5 * init_dbe)
            
    def populate_combinations(self, classe_tuple, settings):
        
        ion_charge =  0
        
        class_dict = classe_tuple[1]
        odd_or_even = self.get_h_odd_or_even(class_dict)
        
        return self.get_mol_formulas(odd_or_even, classe_tuple, settings)
        
    def get_or_add(self, SomeClass, kw):
            
        obj = self.sql_db.session.query(SomeClass).filter_by(**kw).first()
        if not obj:
            obj = SomeClass(**kw)
        return obj
    
    
    def get_mol_formulas(self, odd_even_tag, classe_tuple, settings):
        
        class_str = classe_tuple[0]
        class_dict = classe_tuple[1]
        classe_id = classe_tuple[2]
        
        results = list()
        
        if &#39;HC&#39; in class_dict:
            del class_dict[&#39;HC&#39;]
            
        class_dbe = self.calc_dbe_class(class_dict)    
        class_mass = self.calc_mz(class_dict)
        
        carbonHydrogen_mass = self.odd_ch_mass if odd_even_tag == &#39;odd&#39; else self.even_ch_mass 
        carbonHydrogen_dbe = self.odd_ch_dbe if odd_even_tag == &#39;odd&#39; else self.even_ch_dbe 
        carbonHydrogen_id = self.odd_ch_id if odd_even_tag == &#39;odd&#39; else self.even_ch_id 
        
        for index, carbonHydrogen_obj in enumerate(carbonHydrogen_id):
            
            mass = carbonHydrogen_mass[index] + class_mass
            dbe =  carbonHydrogen_dbe[index] + class_dbe
    
            if settings.min_mz &lt;= mass &lt;= settings.max_mz:
                
                if settings.min_dbe &lt;= dbe &lt;= settings.max_dbe:
                    
                    molecularFormula=  {&#34;heteroAtoms_id&#34;:classe_id, 
                            &#34;carbonHydrogen_id&#34;:carbonHydrogen_id[index], 
                            &#34;mass&#34;:mass, &#34;DBE&#34;:dbe}
                    
                    results.append(molecularFormula)
        
        return results
        
        
    def get_h_odd_or_even(self, class_dict):

        
        HAS_NITROGEN = &#39;N&#39; in class_dict.keys()
        HAS_PHOSPHORUS = &#39;P&#39; in class_dict.keys()

        number_of_halogen = self.get_total_halogen_atoms(class_dict)

        if number_of_halogen &gt; 0:

            TEM_HALOGEN = True

        else:

            TEM_HALOGEN = False

        if TEM_HALOGEN:

            remaining_halogen = number_of_halogen % 2

        else:

            remaining_halogen = 0

        if HAS_NITROGEN and HAS_PHOSPHORUS:

            number_of_n = class_dict.get(&#39;N&#39;) + class_dict.get(&#39;P&#39;)
            remaining_n = number_of_n % 2

        elif HAS_NITROGEN and not HAS_PHOSPHORUS:

            number_of_n = class_dict.get(&#39;N&#39;)
            remaining_n = number_of_n % 2

        elif HAS_PHOSPHORUS and not HAS_NITROGEN:

            number_of_n = class_dict.get(&#39;P&#39;)
            remaining_n = number_of_n % 2

        else:

            remaining_n = -1

        if remaining_n &gt; 0.0:
            if HAS_NITROGEN or HAS_PHOSPHORUS:

                if TEM_HALOGEN:
                    if remaining_halogen == 0:
                        return &#39;odd&#39;
                    else:
                        return &#39;even&#39;
                else:
                    return &#39;odd&#39;

        elif remaining_n == 0.0:

            if HAS_NITROGEN or HAS_PHOSPHORUS:

                if TEM_HALOGEN:
                    if remaining_halogen == 0:
                        return &#39;even&#39;
                    else:
                        return &#39;odd&#39;
                else:
                    return &#39;even&#39;

        else:

            if TEM_HALOGEN:
                if remaining_halogen == 0:
                    return &#39;even&#39;
                else:
                    return &#39;odd&#39;
            else:
                return &#39;even&#39;

    @staticmethod
    def get_total_halogen_atoms(class_dict):

            atoms = [&#39;F&#39;, &#39;Cl&#39;, &#39;Br&#39;, &#39;I&#39;]

            total_number = 0
            
            for atom in atoms:

                if atom in class_dict.keys():

                    total_number = total_number + class_dict.get(atom)
            
            return total_number    </code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_fixed_initial_number_of_hydrogen"><code class="name flex">
<span>def <span class="ident">get_fixed_initial_number_of_hydrogen</span></span>(<span>min_h, odd_even)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_fixed_initial_number_of_hydrogen( min_h, odd_even):

    remaining_h = min_h % 2
    
    if odd_even == &#39;even&#39;:
        
        if remaining_h == 0: return remaining_h
        
        else: return remaining_h + 1    
    
    else:
        
        if remaining_h == 0: return remaining_h + 1
        
        else: return remaining_h    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_total_halogen_atoms"><code class="name flex">
<span>def <span class="ident">get_total_halogen_atoms</span></span>(<span>class_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_total_halogen_atoms(class_dict):

        atoms = [&#39;F&#39;, &#39;Cl&#39;, &#39;Br&#39;, &#39;I&#39;]

        total_number = 0
        
        for atom in atoms:

            if atom in class_dict.keys():

                total_number = total_number + class_dict.get(atom)
        
        return total_number    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.sort_classes"><code class="name flex">
<span>def <span class="ident">sort_classes</span></span>(<span>atoms_in_order, combination_dict) >[<class'str'>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sort_classes( atoms_in_order, combination_dict) -&gt; [str]: 
    #ensures atoms are always in the order defined at atoms_in_order list
    join_dict_classes = dict()
    atoms_in_order =  [&#39;N&#39;,&#39;S&#39;,&#39;P&#39;,&#39;O&#39;] + atoms_in_order[4:] + [&#39;HC&#39;]
    
    sort_method = lambda atoms_keys: [atoms_in_order.index(atoms_keys)] 
    for class_str, class_dict in combination_dict.items():
        
        sorted_dict_keys = sorted(class_dict, key = sort_method)
        class_dict = { atom: class_dict[atom] for atom in sorted_dict_keys}
        class_str = json.dumps(class_dict)
        # using json for the new database, class 
        # class_str = &#39; &#39;.join([atom + str(class_dict[atom]) for atom in sorted_dict_keys])
        join_dict_classes[class_str] =  class_dict
    
    return join_dict_classes</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.add_carbonsHydrogens"><code class="name flex">
<span>def <span class="ident">add_carbonsHydrogens</span></span>(<span>self, settings, existing_classes_objs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_carbonsHydrogens(self, settings, existing_classes_objs):

    usedAtoms = settings.usedAtoms

    user_min_c, user_max_c = usedAtoms.get(&#39;C&#39;)
    user_min_h, user_max_h = usedAtoms.get(&#39;H&#39;)

    query_obj = self.sql_db.session.query(func.max(CarbonHydrogen.C).label(&#34;max_c&#34;), 
                    func.min(CarbonHydrogen.C).label(&#34;min_c&#34;),
                    func.max(CarbonHydrogen.H).label(&#34;max_h&#34;),
                    func.min(CarbonHydrogen.H).label(&#34;min_h&#34;),
                    )


    database = query_obj.first()
    if database.max_c == user_max_c and database.min_c == user_min_c and database.max_h == user_max_h and database.min_h == user_min_h:   
        #all data is already available at the database
        pass

    else:

        current_count = self.sql_db.session.query(CarbonHydrogen.C).count()
        
        databaseCarbonHydrogen = self.sql_db.session.query(CarbonHydrogen).all()
        
        userCarbon = set(range(user_min_c, user_max_c + 1))
        userHydrogen = set(range(user_min_h, user_max_h + 1))
        
        carbon_hydrogen_objs_database = {}
        for obj in databaseCarbonHydrogen:
            
            str_data = &#34;C:{},H:{}&#34;.format(obj.C, obj.H)
            carbon_hydrogen_objs_database[str_data] = str_data

        carbon_hydrogen_objs_to_create = {&#39;even&#39;: {}, &#39;odd&#39;: {}}
        
        list_ch_obj_to_add = list()
        i = 0
        for comb in itertools.product(userCarbon, userHydrogen):
            
            C  = comb[0]
            H =  comb[1]
            data = {&#34;C&#34;:C,
                   &#34;H&#34;:H,
            }

            data_insert = {&#34;C&#34;:C,
                   &#34;H&#34;:H,
            }

            str_data = &#34;C:{},H:{}&#34;.format(C,H)
            
            if not str_data in carbon_hydrogen_objs_database.keys():
                
                label = &#39;even&#39; if comb[1]%2 == 0 else &#39;odd&#39;
                data[&#34;mass&#34;] = (C * Atoms.atomic_masses.get(&#39;C&#39;)) + (H * Atoms.atomic_masses.get(&#39;H&#39;))
                data[&#34;dbe&#34;] = C - (H/2) + 1
                data[&#34;id&#34;] = i + current_count + 1
                data_insert[&#34;id&#34;] = i + current_count + 1
                i = i + 1 
                carbon_hydrogen_objs_to_create[label][str_data] = data
                
                list_ch_obj_to_add.append(data_insert)

        if list_ch_obj_to_add:
            # insert carbon hydrogen objs
            list_insert_chunks = chunks(list_ch_obj_to_add, self.sql_db.chunks_count)
            for insert_chunk in  list_insert_chunks:   
                insert_query = CarbonHydrogen.__table__.insert().values(insert_chunk)
                self.sql_db.session.execute(insert_query)
            self.sql_db.session.commit()    
        
            
            list_molecular_form= list()
            for classe_obj in existing_classes_objs:

                classe_dict = classe_obj.to_dict()  
                classe_mass = self.calc_mz(classe_dict)
                classe_dbe = self.calc_dbe_class(classe_dict)

                odd_even_label = self.get_h_odd_or_even(classe_dict)

                ch_datalist = carbon_hydrogen_objs_to_create.get(odd_even_label).values()

                for ch_dict in ch_datalist:
                    mass = ch_dict.get(&#39;mass&#39;) + classe_mass
                    dbe = ch_dict.get(&#39;dbe&#39;) + classe_dbe

                    if settings.min_mz &lt;= mass &lt;= settings.max_mz:
            
                        if settings.min_dbe &lt;= dbe &lt;= settings.max_dbe:
                            
                            list_molecular_form.append( {&#34;heteroAtoms_id&#34;:classe_obj.id, 
                                    &#34;carbonHydrogen_id&#34;:ch_dict.get(&#39;id&#39;), 
                                    &#34;mass&#34;:mass, &#34;DBE&#34;:dbe})

            list_insert_chunks = chunks(list_molecular_form, self.sql_db.chunks_count)
            for insert_chunk in  list_insert_chunks:   
                insert_query = MolecularFormulaLink.__table__.insert().values(insert_chunk)
                self.sql_db.session.execute(insert_query)
            self.sql_db.session.commit()    </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.cProfile_worker"><code class="name flex">
<span>def <span class="ident">cProfile_worker</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cProfile_worker(self, args):
    
    cProfile.runctx(&#39;self.get_mol_formulas(*args)&#39;, globals(), locals(), &#39;mf_database_cprofile.prof&#39;)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.calc_dbe_class"><code class="name flex">
<span>def <span class="ident">calc_dbe_class</span></span>(<span>self, datadict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dbe_class(self, datadict):
        
        init_dbe = 0
        for atom in datadict.keys():

            if atom == &#39;HC&#39;:
                continue  
            
            n_atom = int(datadict.get(atom))
            
            clean_atom = &#39;&#39;.join([i for i in atom if not i.isdigit()]) 
            
            valencia = MSParameters.molecular_search.used_atom_valences.get(clean_atom)
            
            if type(valencia) is tuple:
                valencia = valencia[0]
            if valencia &gt; 0:
                #print atom, valencia, n_atom, init_dbe
                init_dbe = init_dbe + (n_atom * (valencia - 2))
            else:
                continue
            
        return (0.5 * init_dbe)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.calc_mz"><code class="name flex">
<span>def <span class="ident">calc_mz</span></span>(<span>self, datadict, class_mass=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_mz(self, datadict, class_mass=0):
    
    mass = class_mass
    
    for atom in datadict.keys():
        
        if atom != &#39;HC&#39;:    
            
            mass = mass + Atoms.atomic_masses[atom]  *  datadict.get(atom)
        
    return mass </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.check_database_get_class_list"><code class="name flex">
<span>def <span class="ident">check_database_get_class_list</span></span>(<span>self, molecular_search_settings)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_database_get_class_list(self, molecular_search_settings):
    
    all_class_to_create = []
    
    classes_dict = self.get_classes_in_order(molecular_search_settings)
    
    class_str_set = set(classes_dict.keys())
    
    existing_classes_objs = self.sql_db.session.query(HeteroAtoms).distinct().all()
    
    existing_classes_str = set([classe.name for classe in existing_classes_objs])

    self.len_existing_classes = len(existing_classes_str)

    class_to_create = class_str_set - existing_classes_str
    
    class_count= len(existing_classes_objs)

    data_classes = list()    
    for index, class_str in enumerate(class_to_create):
        
        class_dict = classes_dict.get(class_str)
        halogen_count = self.get_total_halogen_atoms(class_dict)
        data_classes.append({&#34;name&#34;:class_str, &#34;id&#34;:class_count+ index + 1, &#34;halogensCount&#34;: halogen_count})

    #data_classes = [{&#34;name&#34;:class_str, &#34;id&#34;:class_count+ index + 1} for index, class_str in enumerate(class_to_create)]

    if data_classes:

        list_insert_chunks = chunks(data_classes, self.sql_db.chunks_count)
        for insert_chunk in  list_insert_chunks:   
            insert_query = HeteroAtoms.__table__.insert().values(insert_chunk)
            self.sql_db.session.execute(insert_query)

    for index, class_str in enumerate(class_to_create):

        class_tuple = (class_str, classes_dict.get(class_str), class_count+ index + 1)

        all_class_to_create.append(class_tuple)

    return [(c_s, c_d) for c_s, c_d in classes_dict.items()], all_class_to_create, existing_classes_objs       </code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_carbonsHydrogens"><code class="name flex">
<span>def <span class="ident">get_carbonsHydrogens</span></span>(<span>self, settings, odd_even)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_carbonsHydrogens(self, settings, odd_even):

    operator = &#39;==&#39; if odd_even == &#39;even&#39; else &#39;!=&#39; 
    usedAtoms = settings.usedAtoms
    user_min_c, user_max_c = usedAtoms.get(&#39;C&#39;)
    user_min_h, user_max_h = usedAtoms.get(&#39;H&#39;)

    return eval(&#34;self.sql_db.session.query(CarbonHydrogen).filter(&#34; 
                                   &#34;CarbonHydrogen.C &gt;= user_min_c,&#34;
                                    &#34;CarbonHydrogen.H &gt;= user_min_h,&#34;
                                    &#34;CarbonHydrogen.C &lt;= user_max_c,&#34;
                                    &#34;CarbonHydrogen.H &lt;= user_max_h,&#34;
                                    &#34;CarbonHydrogen.H % 2&#34; + operator+ &#34;0).all()&#34;)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_classes_in_order"><code class="name flex">
<span>def <span class="ident">get_classes_in_order</span></span>(<span>self, molecular_search_settings)</span>
</code></dt>
<dd>
<div class="desc"><p>structure is
('HC', {'HC': 1})</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_classes_in_order(self, molecular_search_settings):
    &#39;&#39;&#39; structure is 
        (&#39;HC&#39;, {&#39;HC&#39;: 1})&#39;&#39;&#39;
    
    usedAtoms = deepcopy(molecular_search_settings.usedAtoms)
    
    usedAtoms.pop(&#34;C&#34;)
    usedAtoms.pop(&#34;H&#34;)

    min_n, max_n = usedAtoms.get(&#39;N&#39;) if usedAtoms.get(&#39;N&#39;) else (0,0)
    min_o, max_o = usedAtoms.get(&#39;O&#39;) if usedAtoms.get(&#39;O&#39;) else (0,0)
    min_s, max_s = usedAtoms.get(&#39;S&#39;) if usedAtoms.get(&#39;S&#39;) else (0,0)
    min_p, max_p = usedAtoms.get(&#39;P&#39;) if usedAtoms.get(&#39;P&#39;) else (0,0)

    possible_n = [n for n in range(min_n, max_n + 1)]
    possible_o = [o for o in range(min_o, max_o + 1)]
    possible_s = [s for s in range(min_s, max_s + 1)]
    possible_p = [p for p in range(min_p, max_p + 1)]
    
    atoms_in_order = [&#39;N&#39;, &#39;O&#39;, &#39;S&#39;, &#39;P&#39;]

    classe_in_order = {}

    all_atoms_tuples = itertools.product(possible_n, possible_o,
                                        possible_s, possible_p)
    
    for atom in atoms_in_order:
        usedAtoms.pop(atom, None)
    
    for selected_atom, min_max_tuple in usedAtoms.items():
        
        min_x = min_max_tuple[0]
        max_x = min_max_tuple[1]
        

        possible_x = [x for x in range(min_x, max_x + 1)]

        all_atoms_tuples = itertools.product(all_atoms_tuples, possible_x)
        all_atoms_tuples = [all_atoms_combined[0] + (all_atoms_combined[1],) for all_atoms_combined in
                            all_atoms_tuples]
        atoms_in_order.append(selected_atom)
    
    for all_atoms_tuple in all_atoms_tuples:

        classe_str = &#39;&#39;
        classe_dict = {}
        
        for each_atoms_index, atom_number in enumerate(all_atoms_tuple):
            
            if atom_number != 0:
                classe_dict[atoms_in_order[each_atoms_index]] = atom_number
        
        if not classe_dict:
            classe_in_order[&#39;HC&#39;] = {&#34;HC&#34;: &#34;&#34;}
            continue

        classe_str =json.dumps(classe_dict)
        
        if len(classe_str) &gt; 0:
            
            classe_in_order[classe_str] =  classe_dict
    
    classe_in_order_dict = self.sort_classes(atoms_in_order, classe_in_order)
    
    return classe_in_order_dict</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_h_odd_or_even"><code class="name flex">
<span>def <span class="ident">get_h_odd_or_even</span></span>(<span>self, class_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_h_odd_or_even(self, class_dict):

    
    HAS_NITROGEN = &#39;N&#39; in class_dict.keys()
    HAS_PHOSPHORUS = &#39;P&#39; in class_dict.keys()

    number_of_halogen = self.get_total_halogen_atoms(class_dict)

    if number_of_halogen &gt; 0:

        TEM_HALOGEN = True

    else:

        TEM_HALOGEN = False

    if TEM_HALOGEN:

        remaining_halogen = number_of_halogen % 2

    else:

        remaining_halogen = 0

    if HAS_NITROGEN and HAS_PHOSPHORUS:

        number_of_n = class_dict.get(&#39;N&#39;) + class_dict.get(&#39;P&#39;)
        remaining_n = number_of_n % 2

    elif HAS_NITROGEN and not HAS_PHOSPHORUS:

        number_of_n = class_dict.get(&#39;N&#39;)
        remaining_n = number_of_n % 2

    elif HAS_PHOSPHORUS and not HAS_NITROGEN:

        number_of_n = class_dict.get(&#39;P&#39;)
        remaining_n = number_of_n % 2

    else:

        remaining_n = -1

    if remaining_n &gt; 0.0:
        if HAS_NITROGEN or HAS_PHOSPHORUS:

            if TEM_HALOGEN:
                if remaining_halogen == 0:
                    return &#39;odd&#39;
                else:
                    return &#39;even&#39;
            else:
                return &#39;odd&#39;

    elif remaining_n == 0.0:

        if HAS_NITROGEN or HAS_PHOSPHORUS:

            if TEM_HALOGEN:
                if remaining_halogen == 0:
                    return &#39;even&#39;
                else:
                    return &#39;odd&#39;
            else:
                return &#39;even&#39;

    else:

        if TEM_HALOGEN:
            if remaining_halogen == 0:
                return &#39;even&#39;
            else:
                return &#39;odd&#39;
        else:
            return &#39;even&#39;</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_mol_formulas"><code class="name flex">
<span>def <span class="ident">get_mol_formulas</span></span>(<span>self, odd_even_tag, classe_tuple, settings)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mol_formulas(self, odd_even_tag, classe_tuple, settings):
    
    class_str = classe_tuple[0]
    class_dict = classe_tuple[1]
    classe_id = classe_tuple[2]
    
    results = list()
    
    if &#39;HC&#39; in class_dict:
        del class_dict[&#39;HC&#39;]
        
    class_dbe = self.calc_dbe_class(class_dict)    
    class_mass = self.calc_mz(class_dict)
    
    carbonHydrogen_mass = self.odd_ch_mass if odd_even_tag == &#39;odd&#39; else self.even_ch_mass 
    carbonHydrogen_dbe = self.odd_ch_dbe if odd_even_tag == &#39;odd&#39; else self.even_ch_dbe 
    carbonHydrogen_id = self.odd_ch_id if odd_even_tag == &#39;odd&#39; else self.even_ch_id 
    
    for index, carbonHydrogen_obj in enumerate(carbonHydrogen_id):
        
        mass = carbonHydrogen_mass[index] + class_mass
        dbe =  carbonHydrogen_dbe[index] + class_dbe

        if settings.min_mz &lt;= mass &lt;= settings.max_mz:
            
            if settings.min_dbe &lt;= dbe &lt;= settings.max_dbe:
                
                molecularFormula=  {&#34;heteroAtoms_id&#34;:classe_id, 
                        &#34;carbonHydrogen_id&#34;:carbonHydrogen_id[index], 
                        &#34;mass&#34;:mass, &#34;DBE&#34;:dbe}
                
                results.append(molecularFormula)
    
    return results</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_or_add"><code class="name flex">
<span>def <span class="ident">get_or_add</span></span>(<span>self, SomeClass, kw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_add(self, SomeClass, kw):
        
    obj = self.sql_db.session.query(SomeClass).filter_by(**kw).first()
    if not obj:
        obj = SomeClass(**kw)
    return obj</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.populate_combinations"><code class="name flex">
<span>def <span class="ident">populate_combinations</span></span>(<span>self, classe_tuple, settings)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_combinations(self, classe_tuple, settings):
    
    ion_charge =  0
    
    class_dict = classe_tuple[1]
    odd_or_even = self.get_h_odd_or_even(class_dict)
    
    return self.get_mol_formulas(odd_or_even, classe_tuple, settings)</code></pre>
</details>
</dd>
<dt id="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.runworker"><code class="name flex">
<span>def <span class="ident">runworker</span></span>(<span>*args, **kw)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timed(*args, **kw):
    ts = time.time()
    result = method(*args, **kw)
    te = time.time()
    if &#39;log_time&#39; in kw:
        name = kw.get(&#39;log_name&#39;, method.__name__.upper())
        kw[&#39;log_time&#39;][name] = int((te - ts) * 1000)
    else:
        print( &#34;%r  %2.2f ms&#34; % (method.__name__, (te - ts) * 1000))
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.molecular_id.factory" href="index.html">corems.molecular_id.factory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.insert_database_worker" href="#corems.molecular_id.factory.MolecularLookupTable.insert_database_worker">insert_database_worker</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.profiled" href="#corems.molecular_id.factory.MolecularLookupTable.profiled">profiled</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations">MolecularCombinations</a></code></h4>
<ul class="">
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.add_carbonsHydrogens" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.add_carbonsHydrogens">add_carbonsHydrogens</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.cProfile_worker" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.cProfile_worker">cProfile_worker</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.calc_dbe_class" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.calc_dbe_class">calc_dbe_class</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.calc_mz" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.calc_mz">calc_mz</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.check_database_get_class_list" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.check_database_get_class_list">check_database_get_class_list</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_carbonsHydrogens" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_carbonsHydrogens">get_carbonsHydrogens</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_classes_in_order" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_classes_in_order">get_classes_in_order</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_fixed_initial_number_of_hydrogen" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_fixed_initial_number_of_hydrogen">get_fixed_initial_number_of_hydrogen</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_h_odd_or_even" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_h_odd_or_even">get_h_odd_or_even</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_mol_formulas" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_mol_formulas">get_mol_formulas</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_or_add" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_or_add">get_or_add</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_total_halogen_atoms" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.get_total_halogen_atoms">get_total_halogen_atoms</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.populate_combinations" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.populate_combinations">populate_combinations</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.runworker" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.runworker">runworker</a></code></li>
<li><code><a title="corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.sort_classes" href="#corems.molecular_id.factory.MolecularLookupTable.MolecularCombinations.sort_classes">sort_classes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>