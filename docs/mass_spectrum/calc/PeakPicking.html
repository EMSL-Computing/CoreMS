<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>corems.mass_spectrum.calc.PeakPicking API documentation</title>
<meta name="description" content="@author: Yuri E. Corilo
@date: Jun 27, 2019" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>corems.mass_spectrum.calc.PeakPicking</code></h1>
</header>
<section id="section-intro">
<p>@author: Yuri E. Corilo
@date: Jun 27, 2019</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
@author: Yuri E. Corilo
@date: Jun 27, 2019
&#39;&#39;&#39;

from numpy import hstack, inf, isnan, poly1d, polyfit, where
from corems.encapsulation.constant import Labels

class PeakPicking:

    def cut_mz_domain_peak_picking(self):

        max_picking_mz = self.settings.max_picking_mz
        min_picking_mz = self.settings.min_picking_mz

        min_final = where(self.mz_exp_profile &gt; min_picking_mz)[-1][-1]
        min_comeco = where(self.mz_exp_profile &gt; min_picking_mz)[0][0]

        mz_domain_X_low_cutoff, mz_domain_low_Y_cutoff, = self.mz_exp_profile[min_comeco: min_final], self.abundance_profile[min_comeco: min_final]

        max_final = where(self.mz_exp_profile &lt; max_picking_mz)[-1][-1]
        max_comeco = where(self.mz_exp_profile &lt; max_picking_mz)[0][0]

        if self.has_frequency:

            if self.freq_exp_profile.any():

                freq_domain_low_Y_cutoff = self.freq_exp_profile[min_comeco:min_final]

                return mz_domain_X_low_cutoff[max_comeco:max_final], mz_domain_low_Y_cutoff[max_comeco:max_final], freq_domain_low_Y_cutoff[max_comeco:max_final]

        else:

            return mz_domain_X_low_cutoff[max_comeco:max_final], mz_domain_low_Y_cutoff[max_comeco:max_final], None

    def do_peak_picking(self):

        mz, abudance, freq = self.cut_mz_domain_peak_picking()

        if self.label == Labels.bruker_frequency or self.label == Labels.midas_frequency:

            self.calc_centroid(mz, abudance, freq)

        elif self.label == Labels.thermo_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        elif self.label == Labels.bruker_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        elif self.label == Labels.booster_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        elif self.label == Labels.simulated_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        else: raise Exception(&#34;Unknow mass spectrum type&#34;, self.label)

    def find_minima(self, apex_index, abundance, len_abundance, right=True):
            
            j = apex_index
            
            if right: minima = abundance[j] &gt; abundance[j+1]
            else: minima = abundance[j] &gt; abundance[j-1]

            while minima:
                
                if j == 1 or j == len_abundance -2:
                    break
                
                if right: 
                    j += 1

                    minima = abundance[j] &gt;= abundance[j+1]

                else: 
                    j -= 1
                    minima = abundance[j] &gt;= abundance[j-1]
            
            if right: return j
            else: return j

    def calculate_resolving_power(self, intes, massa, current_index):
            
            &#39;&#39;&#39;this is a conservative calculation of resolving power,
               the peak need to be resolved at least at the half-maximum magnitude,
               otherwise, the combined full width at half maximum is used to calculate resolving power&#39;&#39;&#39;

            peak_height = intes[current_index]
            target_peak_height = peak_height/2

            peak_height_minus = peak_height
            peak_height_plus = peak_height

            index_minus = current_index
            while peak_height_minus  &gt;= target_peak_height:

                index_minus = index_minus -1
                peak_height_minus = intes[index_minus]
                #print &#34;massa&#34;, &#34;,&#34; , &#34;intes&#34;, &#34;,&#34; , massa[index_minus], &#34;,&#34; , peak_height_minus
            x = [ massa[index_minus],  massa[index_minus+1]]
            y = [ intes[index_minus],  intes[index_minus+1]]
            coefficients = polyfit(x, y, 1)

            a = coefficients[0]
            b = coefficients[1]

            y_intercept =  intes[index_minus] + ((intes[index_minus+1] - intes[index_minus])/2)
            massa1 = (y_intercept -b)/a

            index_plus = current_index
            while peak_height_plus  &gt;= target_peak_height:

                index_plus = index_plus + 1
                peak_height_plus = intes[index_plus]
                #print &#34;massa&#34;, &#34;,&#34; , &#34;intes&#34;, &#34;,&#34; , massa[index_plus], &#34;,&#34; , peak_height_plus

            x = [massa[index_plus],  massa[index_plus - 1]]
            y = [intes[index_plus],  intes[index_plus - 1]]

            coefficients = polyfit(x, y, 1)
            a = coefficients[0]
            b = coefficients[1]

            y_intercept =  intes[index_plus - 1] + ((intes[index_plus] - intes[index_plus - 1])/2)
            massa2 = (y_intercept -b)/a

            if massa1 &gt; massa2:

                resolvingpower =  massa[current_index]/(massa1-massa2)

            else:

                resolvingpower =  massa[current_index]/(massa2-massa1)

            return resolvingpower

    def cal_minima(self, mass, abun):

        abun = -abun

        dy = abun[1:] - abun[:-1]
        
        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abun))[0]
        
        if indices_nan.size:
            
            abun[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf
        
        indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]

        if indexes.size:
            
            return mass[indexes], abun[indexes]
    
    def calc_centroid(self, mass, abund, freq):
        #TODO: remove peaks that minimum is one data point from the maximum
        # to remove artifacts 

        len_abundance = len(abund)
        
        max_abundance = max(abund)
        
        peak_height_diff = lambda hi, li : ((abund[hi] - abund[li]) / max_abundance )*100

        abundance_threshold, factor = self.get_threshold(abund)
        #print(abundance_threshold, factor)
        # find indices of all peaks
        dy = abund[1:] - abund[:-1]
        
        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abund))[0]
        
        if indices_nan.size:
            
            abund[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf
        
        indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]
        
        # noise threshold
        if indexes.size and abundance_threshold is not None:
            indexes = indexes[abund[indexes]/factor &gt;= abundance_threshold]
            
        for current_index in indexes: 
            
            if self.label == Labels.simulated_profile: 

                mz_exp_centroid, intes_centr, peak_indexes = self.use_the_max(mass, abund, current_index, len_abundance, peak_height_diff)
                if mz_exp_centroid:
                    
                    peak_resolving_power = self.calculate_resolving_power( abund, mass, current_index)
                    s2n = intes_centr/self.baseline_noise_std
                    freq_centr = None
                    self.add_mspeak(self.polarity, mz_exp_centroid, abund[current_index] , peak_resolving_power, s2n, peak_indexes, exp_freq=freq_centr, ms_parent=self)
            
            else:
            
                mz_exp_centroid, freq_centr, intes_centr, peak_indexes = self.find_apex_fit_quadratic(mass, abund, freq, current_index, len_abundance, peak_height_diff)
                if mz_exp_centroid:
                    
                    peak_resolving_power = self.calculate_resolving_power( abund, mass, current_index)
                    s2n = intes_centr/self.baseline_noise_std
                    self.add_mspeak(self.polarity, mz_exp_centroid, abund[current_index] , peak_resolving_power, s2n, peak_indexes, exp_freq=freq_centr, ms_parent=self)
            
        
    def get_threshold(self, intes):
        
        threshold_method = self.settings.threshold_method

        if threshold_method == &#39;auto&#39;:
            
            #print(self.settings.noise_threshold_std)
            abundance_threshold = self.baseline_noise + (self.settings.noise_threshold_std * self.baseline_noise_std)
            factor = 1

        elif threshold_method == &#39;signal_noise&#39;:

            abundance_threshold = self.settings.s2n_threshold
            factor = self.baseline_noise_std

        elif threshold_method == &#34;relative_abundance&#34;:

            abundance_threshold = self.settings.relative_abundance_threshold
            factor = intes.max()/100

        else:
            raise  Exception(&#34;%s method was not implemented, please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % threshold_method)
        
        return abundance_threshold, factor
        
    def find_apex_fit_quadratic(self, mass, abund, freq, current_index, len_abundance, peak_height_diff):
        
        # calc prominence
        peak_indexes = self.check_prominence(abund, current_index, len_abundance, peak_height_diff )
        
        if not peak_indexes:        
            
            return None, None, None, None           
        
        else:    
            
            # fit parabola to three most abundant datapoints
            list_mass = [mass[current_index - 1], mass[current_index], mass[current_index +1]]
            list_y = [abund[current_index - 1],abund[current_index], abund[current_index +1]]
            
            z = poly1d(polyfit(list_mass, list_y, 2))
            a = z[2]
            b = z[1]

            calculated = -b/(2*a)
            
            if calculated &lt; 1 or int(calculated) != int(list_mass[1]):

                mz_exp_centroid = list_mass[1]
            
            else:
                
                mz_exp_centroid = calculated 
            
            if self.label == Labels.bruker_frequency or self.label == Labels.midas_frequency:
                
                # fit parabola to three most abundant frequency datapoints
                list_freq = [freq[current_index - 1], freq[current_index], freq[current_index +1]]
                z = poly1d(polyfit(list_freq, list_y, 2))
                a = z[2]
                b = z[1]

                calculated_freq = -b/(2*a)

                if calculated_freq &lt; 1 or int(calculated_freq) != freq[current_index]:
                    freq_centr = list_freq[1]

                else:
                    freq_centr = calculated_freq
            
            else:
                    freq_centr = None
                    
            return mz_exp_centroid, freq_centr, abund[current_index], peak_indexes
    
    def check_prominence(self, abun, current_index, len_abundance, peak_height_diff ):

        final_index = self.find_minima(current_index, abun, len_abundance, right=True)
            
        start_index = self.find_minima(current_index, abun, len_abundance, right=False)
            
        peak_indexes = (start_index, current_index, final_index)

        if min( peak_height_diff(current_index,start_index), peak_height_diff(current_index,final_index) ) &gt;  self.mspeaks_settings.peak_min_prominence_percent :   
            
            return peak_indexes
        
        else:
            
            return False

    def use_the_max(self, mass, abund, current_index, len_abundance, peak_height_diff):

        peak_indexes = self.check_prominence(abund, current_index, len_abundance, peak_height_diff )
        
        if not peak_indexes:        

            return None, None, None
        
        else:    
            
            return mass[current_index], abund[current_index], peak_indexes


                    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking"><code class="flex name class">
<span>class <span class="ident">PeakPicking</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PeakPicking:

    def cut_mz_domain_peak_picking(self):

        max_picking_mz = self.settings.max_picking_mz
        min_picking_mz = self.settings.min_picking_mz

        min_final = where(self.mz_exp_profile &gt; min_picking_mz)[-1][-1]
        min_comeco = where(self.mz_exp_profile &gt; min_picking_mz)[0][0]

        mz_domain_X_low_cutoff, mz_domain_low_Y_cutoff, = self.mz_exp_profile[min_comeco: min_final], self.abundance_profile[min_comeco: min_final]

        max_final = where(self.mz_exp_profile &lt; max_picking_mz)[-1][-1]
        max_comeco = where(self.mz_exp_profile &lt; max_picking_mz)[0][0]

        if self.has_frequency:

            if self.freq_exp_profile.any():

                freq_domain_low_Y_cutoff = self.freq_exp_profile[min_comeco:min_final]

                return mz_domain_X_low_cutoff[max_comeco:max_final], mz_domain_low_Y_cutoff[max_comeco:max_final], freq_domain_low_Y_cutoff[max_comeco:max_final]

        else:

            return mz_domain_X_low_cutoff[max_comeco:max_final], mz_domain_low_Y_cutoff[max_comeco:max_final], None

    def do_peak_picking(self):

        mz, abudance, freq = self.cut_mz_domain_peak_picking()

        if self.label == Labels.bruker_frequency or self.label == Labels.midas_frequency:

            self.calc_centroid(mz, abudance, freq)

        elif self.label == Labels.thermo_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        elif self.label == Labels.bruker_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        elif self.label == Labels.booster_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        elif self.label == Labels.simulated_profile:
            self.calc_centroid(mz, abudance, self.freq_exp_profile)

        else: raise Exception(&#34;Unknow mass spectrum type&#34;, self.label)

    def find_minima(self, apex_index, abundance, len_abundance, right=True):
            
            j = apex_index
            
            if right: minima = abundance[j] &gt; abundance[j+1]
            else: minima = abundance[j] &gt; abundance[j-1]

            while minima:
                
                if j == 1 or j == len_abundance -2:
                    break
                
                if right: 
                    j += 1

                    minima = abundance[j] &gt;= abundance[j+1]

                else: 
                    j -= 1
                    minima = abundance[j] &gt;= abundance[j-1]
            
            if right: return j
            else: return j

    def calculate_resolving_power(self, intes, massa, current_index):
            
            &#39;&#39;&#39;this is a conservative calculation of resolving power,
               the peak need to be resolved at least at the half-maximum magnitude,
               otherwise, the combined full width at half maximum is used to calculate resolving power&#39;&#39;&#39;

            peak_height = intes[current_index]
            target_peak_height = peak_height/2

            peak_height_minus = peak_height
            peak_height_plus = peak_height

            index_minus = current_index
            while peak_height_minus  &gt;= target_peak_height:

                index_minus = index_minus -1
                peak_height_minus = intes[index_minus]
                #print &#34;massa&#34;, &#34;,&#34; , &#34;intes&#34;, &#34;,&#34; , massa[index_minus], &#34;,&#34; , peak_height_minus
            x = [ massa[index_minus],  massa[index_minus+1]]
            y = [ intes[index_minus],  intes[index_minus+1]]
            coefficients = polyfit(x, y, 1)

            a = coefficients[0]
            b = coefficients[1]

            y_intercept =  intes[index_minus] + ((intes[index_minus+1] - intes[index_minus])/2)
            massa1 = (y_intercept -b)/a

            index_plus = current_index
            while peak_height_plus  &gt;= target_peak_height:

                index_plus = index_plus + 1
                peak_height_plus = intes[index_plus]
                #print &#34;massa&#34;, &#34;,&#34; , &#34;intes&#34;, &#34;,&#34; , massa[index_plus], &#34;,&#34; , peak_height_plus

            x = [massa[index_plus],  massa[index_plus - 1]]
            y = [intes[index_plus],  intes[index_plus - 1]]

            coefficients = polyfit(x, y, 1)
            a = coefficients[0]
            b = coefficients[1]

            y_intercept =  intes[index_plus - 1] + ((intes[index_plus] - intes[index_plus - 1])/2)
            massa2 = (y_intercept -b)/a

            if massa1 &gt; massa2:

                resolvingpower =  massa[current_index]/(massa1-massa2)

            else:

                resolvingpower =  massa[current_index]/(massa2-massa1)

            return resolvingpower

    def cal_minima(self, mass, abun):

        abun = -abun

        dy = abun[1:] - abun[:-1]
        
        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abun))[0]
        
        if indices_nan.size:
            
            abun[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf
        
        indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]

        if indexes.size:
            
            return mass[indexes], abun[indexes]
    
    def calc_centroid(self, mass, abund, freq):
        #TODO: remove peaks that minimum is one data point from the maximum
        # to remove artifacts 

        len_abundance = len(abund)
        
        max_abundance = max(abund)
        
        peak_height_diff = lambda hi, li : ((abund[hi] - abund[li]) / max_abundance )*100

        abundance_threshold, factor = self.get_threshold(abund)
        #print(abundance_threshold, factor)
        # find indices of all peaks
        dy = abund[1:] - abund[:-1]
        
        &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
        indices_nan = where(isnan(abund))[0]
        
        if indices_nan.size:
            
            abund[indices_nan] = inf
            dy[where(isnan(dy))[0]] = inf
        
        indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]
        
        # noise threshold
        if indexes.size and abundance_threshold is not None:
            indexes = indexes[abund[indexes]/factor &gt;= abundance_threshold]
            
        for current_index in indexes: 
            
            if self.label == Labels.simulated_profile: 

                mz_exp_centroid, intes_centr, peak_indexes = self.use_the_max(mass, abund, current_index, len_abundance, peak_height_diff)
                if mz_exp_centroid:
                    
                    peak_resolving_power = self.calculate_resolving_power( abund, mass, current_index)
                    s2n = intes_centr/self.baseline_noise_std
                    freq_centr = None
                    self.add_mspeak(self.polarity, mz_exp_centroid, abund[current_index] , peak_resolving_power, s2n, peak_indexes, exp_freq=freq_centr, ms_parent=self)
            
            else:
            
                mz_exp_centroid, freq_centr, intes_centr, peak_indexes = self.find_apex_fit_quadratic(mass, abund, freq, current_index, len_abundance, peak_height_diff)
                if mz_exp_centroid:
                    
                    peak_resolving_power = self.calculate_resolving_power( abund, mass, current_index)
                    s2n = intes_centr/self.baseline_noise_std
                    self.add_mspeak(self.polarity, mz_exp_centroid, abund[current_index] , peak_resolving_power, s2n, peak_indexes, exp_freq=freq_centr, ms_parent=self)
            
        
    def get_threshold(self, intes):
        
        threshold_method = self.settings.threshold_method

        if threshold_method == &#39;auto&#39;:
            
            #print(self.settings.noise_threshold_std)
            abundance_threshold = self.baseline_noise + (self.settings.noise_threshold_std * self.baseline_noise_std)
            factor = 1

        elif threshold_method == &#39;signal_noise&#39;:

            abundance_threshold = self.settings.s2n_threshold
            factor = self.baseline_noise_std

        elif threshold_method == &#34;relative_abundance&#34;:

            abundance_threshold = self.settings.relative_abundance_threshold
            factor = intes.max()/100

        else:
            raise  Exception(&#34;%s method was not implemented, please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % threshold_method)
        
        return abundance_threshold, factor
        
    def find_apex_fit_quadratic(self, mass, abund, freq, current_index, len_abundance, peak_height_diff):
        
        # calc prominence
        peak_indexes = self.check_prominence(abund, current_index, len_abundance, peak_height_diff )
        
        if not peak_indexes:        
            
            return None, None, None, None           
        
        else:    
            
            # fit parabola to three most abundant datapoints
            list_mass = [mass[current_index - 1], mass[current_index], mass[current_index +1]]
            list_y = [abund[current_index - 1],abund[current_index], abund[current_index +1]]
            
            z = poly1d(polyfit(list_mass, list_y, 2))
            a = z[2]
            b = z[1]

            calculated = -b/(2*a)
            
            if calculated &lt; 1 or int(calculated) != int(list_mass[1]):

                mz_exp_centroid = list_mass[1]
            
            else:
                
                mz_exp_centroid = calculated 
            
            if self.label == Labels.bruker_frequency or self.label == Labels.midas_frequency:
                
                # fit parabola to three most abundant frequency datapoints
                list_freq = [freq[current_index - 1], freq[current_index], freq[current_index +1]]
                z = poly1d(polyfit(list_freq, list_y, 2))
                a = z[2]
                b = z[1]

                calculated_freq = -b/(2*a)

                if calculated_freq &lt; 1 or int(calculated_freq) != freq[current_index]:
                    freq_centr = list_freq[1]

                else:
                    freq_centr = calculated_freq
            
            else:
                    freq_centr = None
                    
            return mz_exp_centroid, freq_centr, abund[current_index], peak_indexes
    
    def check_prominence(self, abun, current_index, len_abundance, peak_height_diff ):

        final_index = self.find_minima(current_index, abun, len_abundance, right=True)
            
        start_index = self.find_minima(current_index, abun, len_abundance, right=False)
            
        peak_indexes = (start_index, current_index, final_index)

        if min( peak_height_diff(current_index,start_index), peak_height_diff(current_index,final_index) ) &gt;  self.mspeaks_settings.peak_min_prominence_percent :   
            
            return peak_indexes
        
        else:
            
            return False

    def use_the_max(self, mass, abund, current_index, len_abundance, peak_height_diff):

        peak_indexes = self.check_prominence(abund, current_index, len_abundance, peak_height_diff )
        
        if not peak_indexes:        

            return None, None, None
        
        else:    
            
            return mass[current_index], abund[current_index], peak_indexes</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc" href="MassSpectrumCalc.html#corems.mass_spectrum.calc.MassSpectrumCalc.MassSpecCalc">MassSpecCalc</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.cal_minima"><code class="name flex">
<span>def <span class="ident">cal_minima</span></span>(<span>self, mass, abun)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cal_minima(self, mass, abun):

    abun = -abun

    dy = abun[1:] - abun[:-1]
    
    &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
    indices_nan = where(isnan(abun))[0]
    
    if indices_nan.size:
        
        abun[indices_nan] = inf
        dy[where(isnan(dy))[0]] = inf
    
    indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]

    if indexes.size:
        
        return mass[indexes], abun[indexes]</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.calc_centroid"><code class="name flex">
<span>def <span class="ident">calc_centroid</span></span>(<span>self, mass, abund, freq)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_centroid(self, mass, abund, freq):
    #TODO: remove peaks that minimum is one data point from the maximum
    # to remove artifacts 

    len_abundance = len(abund)
    
    max_abundance = max(abund)
    
    peak_height_diff = lambda hi, li : ((abund[hi] - abund[li]) / max_abundance )*100

    abundance_threshold, factor = self.get_threshold(abund)
    #print(abundance_threshold, factor)
    # find indices of all peaks
    dy = abund[1:] - abund[:-1]
    
    &#39;&#39;&#39;replaces nan for infinity&#39;&#39;&#39;
    indices_nan = where(isnan(abund))[0]
    
    if indices_nan.size:
        
        abund[indices_nan] = inf
        dy[where(isnan(dy))[0]] = inf
    
    indexes = where((hstack((dy, 0)) &lt; 0) &amp; (hstack((0, dy)) &gt; 0))[0]
    
    # noise threshold
    if indexes.size and abundance_threshold is not None:
        indexes = indexes[abund[indexes]/factor &gt;= abundance_threshold]
        
    for current_index in indexes: 
        
        if self.label == Labels.simulated_profile: 

            mz_exp_centroid, intes_centr, peak_indexes = self.use_the_max(mass, abund, current_index, len_abundance, peak_height_diff)
            if mz_exp_centroid:
                
                peak_resolving_power = self.calculate_resolving_power( abund, mass, current_index)
                s2n = intes_centr/self.baseline_noise_std
                freq_centr = None
                self.add_mspeak(self.polarity, mz_exp_centroid, abund[current_index] , peak_resolving_power, s2n, peak_indexes, exp_freq=freq_centr, ms_parent=self)
        
        else:
        
            mz_exp_centroid, freq_centr, intes_centr, peak_indexes = self.find_apex_fit_quadratic(mass, abund, freq, current_index, len_abundance, peak_height_diff)
            if mz_exp_centroid:
                
                peak_resolving_power = self.calculate_resolving_power( abund, mass, current_index)
                s2n = intes_centr/self.baseline_noise_std
                self.add_mspeak(self.polarity, mz_exp_centroid, abund[current_index] , peak_resolving_power, s2n, peak_indexes, exp_freq=freq_centr, ms_parent=self)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power"><code class="name flex">
<span>def <span class="ident">calculate_resolving_power</span></span>(<span>self, intes, massa, current_index)</span>
</code></dt>
<dd>
<div class="desc"><p>this is a conservative calculation of resolving power,
the peak need to be resolved at least at the half-maximum magnitude,
otherwise, the combined full width at half maximum is used to calculate resolving power</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_resolving_power(self, intes, massa, current_index):
        
        &#39;&#39;&#39;this is a conservative calculation of resolving power,
           the peak need to be resolved at least at the half-maximum magnitude,
           otherwise, the combined full width at half maximum is used to calculate resolving power&#39;&#39;&#39;

        peak_height = intes[current_index]
        target_peak_height = peak_height/2

        peak_height_minus = peak_height
        peak_height_plus = peak_height

        index_minus = current_index
        while peak_height_minus  &gt;= target_peak_height:

            index_minus = index_minus -1
            peak_height_minus = intes[index_minus]
            #print &#34;massa&#34;, &#34;,&#34; , &#34;intes&#34;, &#34;,&#34; , massa[index_minus], &#34;,&#34; , peak_height_minus
        x = [ massa[index_minus],  massa[index_minus+1]]
        y = [ intes[index_minus],  intes[index_minus+1]]
        coefficients = polyfit(x, y, 1)

        a = coefficients[0]
        b = coefficients[1]

        y_intercept =  intes[index_minus] + ((intes[index_minus+1] - intes[index_minus])/2)
        massa1 = (y_intercept -b)/a

        index_plus = current_index
        while peak_height_plus  &gt;= target_peak_height:

            index_plus = index_plus + 1
            peak_height_plus = intes[index_plus]
            #print &#34;massa&#34;, &#34;,&#34; , &#34;intes&#34;, &#34;,&#34; , massa[index_plus], &#34;,&#34; , peak_height_plus

        x = [massa[index_plus],  massa[index_plus - 1]]
        y = [intes[index_plus],  intes[index_plus - 1]]

        coefficients = polyfit(x, y, 1)
        a = coefficients[0]
        b = coefficients[1]

        y_intercept =  intes[index_plus - 1] + ((intes[index_plus] - intes[index_plus - 1])/2)
        massa2 = (y_intercept -b)/a

        if massa1 &gt; massa2:

            resolvingpower =  massa[current_index]/(massa1-massa2)

        else:

            resolvingpower =  massa[current_index]/(massa2-massa1)

        return resolvingpower</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.check_prominence"><code class="name flex">
<span>def <span class="ident">check_prominence</span></span>(<span>self, abun, current_index, len_abundance, peak_height_diff)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_prominence(self, abun, current_index, len_abundance, peak_height_diff ):

    final_index = self.find_minima(current_index, abun, len_abundance, right=True)
        
    start_index = self.find_minima(current_index, abun, len_abundance, right=False)
        
    peak_indexes = (start_index, current_index, final_index)

    if min( peak_height_diff(current_index,start_index), peak_height_diff(current_index,final_index) ) &gt;  self.mspeaks_settings.peak_min_prominence_percent :   
        
        return peak_indexes
    
    else:
        
        return False</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.cut_mz_domain_peak_picking"><code class="name flex">
<span>def <span class="ident">cut_mz_domain_peak_picking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_mz_domain_peak_picking(self):

    max_picking_mz = self.settings.max_picking_mz
    min_picking_mz = self.settings.min_picking_mz

    min_final = where(self.mz_exp_profile &gt; min_picking_mz)[-1][-1]
    min_comeco = where(self.mz_exp_profile &gt; min_picking_mz)[0][0]

    mz_domain_X_low_cutoff, mz_domain_low_Y_cutoff, = self.mz_exp_profile[min_comeco: min_final], self.abundance_profile[min_comeco: min_final]

    max_final = where(self.mz_exp_profile &lt; max_picking_mz)[-1][-1]
    max_comeco = where(self.mz_exp_profile &lt; max_picking_mz)[0][0]

    if self.has_frequency:

        if self.freq_exp_profile.any():

            freq_domain_low_Y_cutoff = self.freq_exp_profile[min_comeco:min_final]

            return mz_domain_X_low_cutoff[max_comeco:max_final], mz_domain_low_Y_cutoff[max_comeco:max_final], freq_domain_low_Y_cutoff[max_comeco:max_final]

    else:

        return mz_domain_X_low_cutoff[max_comeco:max_final], mz_domain_low_Y_cutoff[max_comeco:max_final], None</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.do_peak_picking"><code class="name flex">
<span>def <span class="ident">do_peak_picking</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_peak_picking(self):

    mz, abudance, freq = self.cut_mz_domain_peak_picking()

    if self.label == Labels.bruker_frequency or self.label == Labels.midas_frequency:

        self.calc_centroid(mz, abudance, freq)

    elif self.label == Labels.thermo_profile:
        self.calc_centroid(mz, abudance, self.freq_exp_profile)

    elif self.label == Labels.bruker_profile:
        self.calc_centroid(mz, abudance, self.freq_exp_profile)

    elif self.label == Labels.booster_profile:
        self.calc_centroid(mz, abudance, self.freq_exp_profile)

    elif self.label == Labels.simulated_profile:
        self.calc_centroid(mz, abudance, self.freq_exp_profile)

    else: raise Exception(&#34;Unknow mass spectrum type&#34;, self.label)</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.find_apex_fit_quadratic"><code class="name flex">
<span>def <span class="ident">find_apex_fit_quadratic</span></span>(<span>self, mass, abund, freq, current_index, len_abundance, peak_height_diff)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_apex_fit_quadratic(self, mass, abund, freq, current_index, len_abundance, peak_height_diff):
    
    # calc prominence
    peak_indexes = self.check_prominence(abund, current_index, len_abundance, peak_height_diff )
    
    if not peak_indexes:        
        
        return None, None, None, None           
    
    else:    
        
        # fit parabola to three most abundant datapoints
        list_mass = [mass[current_index - 1], mass[current_index], mass[current_index +1]]
        list_y = [abund[current_index - 1],abund[current_index], abund[current_index +1]]
        
        z = poly1d(polyfit(list_mass, list_y, 2))
        a = z[2]
        b = z[1]

        calculated = -b/(2*a)
        
        if calculated &lt; 1 or int(calculated) != int(list_mass[1]):

            mz_exp_centroid = list_mass[1]
        
        else:
            
            mz_exp_centroid = calculated 
        
        if self.label == Labels.bruker_frequency or self.label == Labels.midas_frequency:
            
            # fit parabola to three most abundant frequency datapoints
            list_freq = [freq[current_index - 1], freq[current_index], freq[current_index +1]]
            z = poly1d(polyfit(list_freq, list_y, 2))
            a = z[2]
            b = z[1]

            calculated_freq = -b/(2*a)

            if calculated_freq &lt; 1 or int(calculated_freq) != freq[current_index]:
                freq_centr = list_freq[1]

            else:
                freq_centr = calculated_freq
        
        else:
                freq_centr = None
                
        return mz_exp_centroid, freq_centr, abund[current_index], peak_indexes</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.find_minima"><code class="name flex">
<span>def <span class="ident">find_minima</span></span>(<span>self, apex_index, abundance, len_abundance, right=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_minima(self, apex_index, abundance, len_abundance, right=True):
        
        j = apex_index
        
        if right: minima = abundance[j] &gt; abundance[j+1]
        else: minima = abundance[j] &gt; abundance[j-1]

        while minima:
            
            if j == 1 or j == len_abundance -2:
                break
            
            if right: 
                j += 1

                minima = abundance[j] &gt;= abundance[j+1]

            else: 
                j -= 1
                minima = abundance[j] &gt;= abundance[j-1]
        
        if right: return j
        else: return j</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.get_threshold"><code class="name flex">
<span>def <span class="ident">get_threshold</span></span>(<span>self, intes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_threshold(self, intes):
    
    threshold_method = self.settings.threshold_method

    if threshold_method == &#39;auto&#39;:
        
        #print(self.settings.noise_threshold_std)
        abundance_threshold = self.baseline_noise + (self.settings.noise_threshold_std * self.baseline_noise_std)
        factor = 1

    elif threshold_method == &#39;signal_noise&#39;:

        abundance_threshold = self.settings.s2n_threshold
        factor = self.baseline_noise_std

    elif threshold_method == &#34;relative_abundance&#34;:

        abundance_threshold = self.settings.relative_abundance_threshold
        factor = intes.max()/100

    else:
        raise  Exception(&#34;%s method was not implemented, please refer to corems.mass_spectrum.calc.NoiseCalc Class&#34; % threshold_method)
    
    return abundance_threshold, factor</code></pre>
</details>
</dd>
<dt id="corems.mass_spectrum.calc.PeakPicking.PeakPicking.use_the_max"><code class="name flex">
<span>def <span class="ident">use_the_max</span></span>(<span>self, mass, abund, current_index, len_abundance, peak_height_diff)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use_the_max(self, mass, abund, current_index, len_abundance, peak_height_diff):

    peak_indexes = self.check_prominence(abund, current_index, len_abundance, peak_height_diff )
    
    if not peak_indexes:        

        return None, None, None
    
    else:    
        
        return mass[current_index], abund[current_index], peak_indexes</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="corems.mass_spectrum.calc" href="index.html">corems.mass_spectrum.calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking">PeakPicking</a></code></h4>
<ul class="">
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.cal_minima" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.cal_minima">cal_minima</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.calc_centroid" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calc_centroid">calc_centroid</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.calculate_resolving_power">calculate_resolving_power</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.check_prominence" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.check_prominence">check_prominence</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.cut_mz_domain_peak_picking" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.cut_mz_domain_peak_picking">cut_mz_domain_peak_picking</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.do_peak_picking" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.do_peak_picking">do_peak_picking</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.find_apex_fit_quadratic" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.find_apex_fit_quadratic">find_apex_fit_quadratic</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.find_minima" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.find_minima">find_minima</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.get_threshold" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.get_threshold">get_threshold</a></code></li>
<li><code><a title="corems.mass_spectrum.calc.PeakPicking.PeakPicking.use_the_max" href="#corems.mass_spectrum.calc.PeakPicking.PeakPicking.use_the_max">use_the_max</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>